{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to <code>mifarepy</code> Documentation! \ud83d\ude80","text":"<p><code>mifarepy</code> is a Python library for interfacing with MIFARE RFID card readers using the GNetPlus\u00ae protocol. This documentation is designed to help you get started quickly and dive into advanced operations as needed.</p>"},{"location":"#getting-started","title":"\ud83d\udccc Getting Started","text":"<ul> <li>\ud83d\udce5 Installation: How to install the library via PyPI or manually.</li> <li>\ud83d\ude80 Usage Guide: Learn how to connect to a reader, read and write data, and more.</li> <li>\ud83d\udee0 API Reference: Detailed technical reference for classes, methods, and constants.</li> <li>\ud83d\udcdd Examples: Practical code examples demonstrating typical usage.</li> <li>\ud83e\udd1d Contributing: Guidelines on contributing to the project.</li> </ul> <p>GitHub Repo: mifarepy on GitHub PyPI: mifarepy on PyPI</p> <p>We hope this documentation helps you integrate and utilize <code>mifarepy</code> effectively!</p>"},{"location":"CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and maintainers pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery and sexual attention or advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject contributions that are not aligned with this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at <code>huzaifa.farooq@aarsol.com</code>. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community members are expected to abide by this Code of Conduct. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project\u2019s leadership.</p>"},{"location":"CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p>"},{"location":"api/","title":"API Reference \u2014 <code>mifarepy</code>","text":"<p>This document provides a detailed overview of the classes, methods, and constants available in the <code>mifarepy</code> library, which is used to interface with PROMAG RFID card readers using the GNetPlus\u00ae protocol.</p>"},{"location":"api/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Exceptions<ul> <li>InvalidMessage</li> <li>GNetPlusError</li> </ul> </li> <li>Message Classes<ul> <li>Message</li> <li>QueryMessage</li> <li>ResponseMessage</li> </ul> </li> <li>Handle Class<ul> <li>Constructor</li> <li>sendmsg</li> <li>readmsg</li> <li>get_sn</li> <li>get_version</li> <li>set_auto_mode</li> <li>wait_for_card</li> </ul> </li> <li>Additional Notes</li> </ul>"},{"location":"api/#exceptions","title":"Exceptions","text":""},{"location":"api/#class-invalidmessage","title":"Class: <code>InvalidMessage</code>","text":"<ul> <li>Description:   Raised when an invalid message is received from the RFID reader. This can occur if the header is incomplete, the SOH (Start-of-Header) does not match, the data or CRC is incomplete, or if the CRC check fails.</li> <li>Usage:   This exception is automatically raised during message parsing in the <code>Message.readfrom</code> method.</li> </ul>"},{"location":"api/#class-gnetpluserror","title":"Class: <code>GNetPlusError</code>","text":"<ul> <li>Description:   Thrown when a NAK (negative acknowledge) response is received from the RFID reader. This error indicates that an issue occurred during the communication process.</li> <li>Usage:   Raised by the <code>Handle.readmsg</code> method when a NAK response is detected. The error message usually includes details from the response's data payload.</li> </ul>"},{"location":"api/#message-classes","title":"Message Classes","text":""},{"location":"api/#class-message","title":"Class: <code>Message</code>","text":""},{"location":"api/#description","title":"Description","text":"<p>The base class representing a message to be sent to or received from the RFID reader. This class handles message construction, conversion to raw bytes, and CRC checksum generation.</p>"},{"location":"api/#methods","title":"Methods","text":"<ul> <li> <p><code>__init__(self, address: int, function: int, data: Union[bytes, str])</code> Parameters:</p> <ul> <li><code>address</code>: An 8-bit device address (typically 0 unless specified otherwise).</li> <li><code>function</code>: An 8-bit function code representing the type of message.</li> <li><code>data</code>: The payload for the message, provided as either <code>bytes</code> or a <code>str</code> (if a string is provided, it is encoded using Latin-1).</li> </ul> <p>Description: Initializes the message with the specified address, function code, and data.</p> </li> <li> <p><code>__bytes__(self) -&gt; bytes</code> Returns:     The binary (raw byte) representation of the message.</p> <p>Description: Packs the address, function code, and length of the data into bytes, appends the data payload, calculates the 16-bit CRC checksum using <code>gencrc</code>, and then prepends the SOH (Start-of-Header) byte. Message Format: <code>[SOH][address][function][data_length][data][CRC16]</code></p> </li> <li> <p><code>__str__(self) -&gt; str</code> Returns:     A hexadecimal string representation of the message.</p> <p>Description: Converts the binary message (obtained from <code>__bytes__</code>) into a human-readable hex string.</p> </li> <li> <p><code>__repr__(self) -&gt; str</code> Returns:     A debug-friendly string representation of the message, showing the address, function code, and data.</p> <p>Description: Useful for debugging purposes.</p> </li> <li> <p><code>sendto(self, serial_port)</code> Parameters:</p> <ul> <li><code>serial_port</code>: An open serial port (from the <code>pyserial</code> package).</li> </ul> <p>Description: Sends the constructed message over the provided serial port by writing the raw bytes to it.</p> </li> <li> <p><code>@classmethod readfrom(cls, serial_port)</code> Parameters:</p> <ul> <li><code>serial_port</code>: The serial port from which the message is read.</li> </ul> <p>Returns: An instance of the <code>Message</code> class constructed from the read data.</p> <p>Raises: <code>InvalidMessage</code> if the message is incomplete or the CRC check fails.</p> <p>Description: Reads the message header, data payload, and CRC from the serial port, validates the message integrity, and returns a new message instance.</p> </li> <li> <p><code>@staticmethod gencrc(msg_bytes: bytes) -&gt; int</code> Parameters:</p> <ul> <li><code>msg_bytes</code>: The message bytes over which the CRC is calculated.</li> </ul> <p>Returns: A 16-bit integer representing the CRC checksum.</p> <p>Description: Computes a CRC-16 checksum using the polynomial 0xA001 by processing each byte of the message.</p> </li> </ul>"},{"location":"api/#class-querymessage","title":"Class: <code>QueryMessage</code>","text":""},{"location":"api/#description_1","title":"Description","text":"<p>A subclass of <code>Message</code> used specifically for query messages (commands) sent from the host to the RFID reader. This class defines constants for various function codes as specified in the GNetPlus\u00ae protocol.</p>"},{"location":"api/#constants-examples","title":"Constants (Examples)","text":"<ul> <li><code>POLLING = 0x00</code></li> <li><code>GET_VERSION = 0x01</code></li> <li><code>SET_SLAVE_ADDR = 0x02</code></li> <li><code>LOGON = 0x03</code></li> <li><code>LOGOFF = 0x04</code></li> <li>... (continues up to <code>AUTO_MODE = 0x3F</code>)</li> </ul>"},{"location":"api/#usage","title":"Usage","text":"<p>Construct a query message with the desired function code and optional data payload, then send it using the <code>sendto</code> method.</p>"},{"location":"api/#class-responsemessage","title":"Class: <code>ResponseMessage</code>","text":""},{"location":"api/#description_2","title":"Description","text":"<p>A subclass of <code>Message</code> designed for handling responses from the RFID reader.</p>"},{"location":"api/#constants","title":"Constants","text":"<ul> <li><code>ACK = 0x06</code>: Indicates an acknowledgement (successful operation).</li> <li><code>NAK = 0x15</code>: Indicates a negative acknowledgement (error occurred).</li> <li><code>EVN = 0x12</code>: Indicates an event notification.</li> </ul>"},{"location":"api/#methods_1","title":"Methods","text":"<ul> <li> <p><code>to_error(self) -&gt; Optional[GNetPlusError]</code> Returns:     An instance of <code>GNetPlusError</code> if the message\u2019s function code is <code>NAK</code>, otherwise <code>None</code>.</p> <p>Description: Converts a negative acknowledgement response into an error that can be raised by the calling code.</p> </li> </ul>"},{"location":"api/#handle-class","title":"Handle Class","text":""},{"location":"api/#class-handle","title":"Class: <code>Handle</code>","text":""},{"location":"api/#description_3","title":"Description","text":"<p>The primary class for interfacing with the RFID card reader. It encapsulates the serial connection and provides high-level methods to send commands, read responses, and perform operations such as retrieving the card\u2019s serial number.</p>"},{"location":"api/#methods_2","title":"Methods","text":"<ul> <li> <p><code>__init__(self, port: str = '/dev/ttyUSB0', baudrate: int = 19200, deviceaddr: int = 0, **kwargs)</code> Parameters:</p> <ul> <li><code>port</code>: The serial port to connect to (e.g., <code>/dev/ttyUSB0</code>).</li> <li><code>baudrate</code>: The baud rate for the serial connection (default is 19200).</li> <li><code>deviceaddr</code>: The device address; typically 0 unless otherwise specified.</li> <li><code>**kwargs</code>: Additional keyword arguments for the <code>serial.Serial</code> constructor.</li> </ul> <p>Raises: <code>RuntimeError</code> if the serial port cannot be opened.</p> <p>Description: Initializes the serial connection to the RFID reader. If opening the serial port fails, a <code>RuntimeError</code> is raised with an appropriate error message.</p> </li> <li> <p><code>sendmsg(self, function: int, data: bytes = b'') -&gt; None</code> Parameters:</p> <ul> <li><code>function</code>: The function code (from <code>QueryMessage</code>) that specifies the command.</li> <li><code>data</code>: Optional payload data as bytes.</li> </ul> <p>Description: Constructs a <code>QueryMessage</code> using the device\u2019s address, function code, and data, then sends the message over the established serial connection.</p> </li> <li> <p><code>readmsg(self, sink_events: bool = False) -&gt; ResponseMessage</code> Parameters:</p> <ul> <li><code>sink_events</code>: A boolean flag indicating whether to ignore event messages (with function code <code>EVN</code>) until a non-event response is received.</li> </ul> <p>Returns: A <code>ResponseMessage</code> instance containing the data received from the RFID reader.</p> <p>Raises: <code>GNetPlusError</code> if a negative acknowledgement (NAK) response is received.</p> <p>Description: Continuously reads messages from the serial port until a valid (non-event) message is obtained. If a NAK is received, it is converted to a <code>GNetPlusError</code> and raised.</p> </li> <li> <p><code>get_sn(self, endian: str = 'little', as_string: bool = True) -&gt; Union[str, int]</code> Parameters:</p> <ul> <li><code>endian</code>: Specifies the byte order for interpreting the UID. Acceptable values are <code>'big'</code> or <code>'little'</code>.  </li> <li>For example, raw data <code>b'\\xE3\\x0E\\x27\\x0E'</code> is interpreted as:<ul> <li><code>'big'</code>: <code>0xE30E270E</code></li> <li><code>'little'</code>: <code>0x0E270EE3</code></li> </ul> </li> <li><code>as_string</code>: If <code>True</code>, returns the UID as a formatted hexadecimal string (e.g., <code>\"0x0E270EE3\"</code>); otherwise, returns it as an integer.</li> </ul> <p>Returns: The serial number of the card currently scanned.</p> <p>Description: Retrieves the card\u2019s serial number by sending a <code>REQUEST</code> command followed by an <code>ANTI_COLLISION</code> command to resolve potential collisions. The response data is unpacked according to the specified endian format and returned in the requested format.</p> </li> <li> <p><code>get_version(self) -&gt; bytes</code> Returns:     A byte string containing the product version string of the RFID reader.</p> <p>Description: Sends the <code>GET_VERSION</code> command to the RFID reader and returns the version information. The returned bytes may include null characters; therefore, proper handling is recommended when displaying or processing the version string.</p> </li> <li> <p><code>set_auto_mode(self, enabled: bool = True) -&gt; bytes</code> Parameters:</p> <ul> <li><code>enabled</code>: A boolean indicating whether to enable (<code>True</code>) or disable (<code>False</code>) auto mode.</li> </ul> <p>Returns: The response data from the RFID reader as bytes.</p> <p>Raises: <code>GNetPlusError</code> if the response data does not match the expected mode (indicating that setting auto mode failed).</p> <p>Description: Toggles the RFID reader\u2019s auto mode by sending the <code>AUTO_MODE</code> command with the corresponding mode byte (<code>\\x01</code> for enabled, <code>\\x00</code> for disabled). The method then verifies that the response matches the intended mode.</p> </li> <li> <p><code>wait_for_card(self, timeout: int = 10) -&gt; Optional[str]</code> Parameters:</p> <ul> <li><code>timeout</code>: The maximum number of seconds to wait for a card to be detected (default is 10 seconds).</li> </ul> <p>Returns: The card\u2019s serial number as a formatted hexadecimal string if detected; otherwise, returns <code>None</code>.</p> <p>Raises: <code>TimeoutError</code> if no card is detected within the specified timeout period.</p> <p>Description: First attempts to detect a card immediately. If unsuccessful, enters a loop where it periodically checks for a card event. When a card is detected (usually indicated by an event message containing a specific marker), it retrieves and returns the serial number. If no card is detected within the timeout, a <code>TimeoutError</code> is raised.</p> </li> </ul>"},{"location":"api/#additional-notes","title":"Additional Notes","text":"<ul> <li> <p>Data Encoding:   The <code>Message</code> class encodes string data using Latin-1 encoding, ensuring that the data is properly formatted as bytes for serial transmission.</p> </li> <li> <p>CRC Calculation:   The static method <code>gencrc</code> implements a CRC-16 checksum calculation using the polynomial <code>0xA001</code>, ensuring data integrity.</p> </li> <li> <p>Event Handling:   The <code>readmsg</code> method can be set to ignore event messages (with function code <code>EVN</code>) using the <code>sink_events</code> flag, so that only responses to commands are processed.</p> </li> <li> <p>Error Handling:   If a NAK (negative acknowledge) response is received, the <code>to_error</code> method of the <code>ResponseMessage</code> class converts it into a <code>GNetPlusError</code>, which is then raised by <code>readmsg</code>.</p> </li> </ul>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing-to-mifarepy","title":"\ud83e\udd1d Contributing to <code>mifarepy</code>","text":"<p>We welcome contributions from the community! Whether you're reporting bugs, suggesting new features, or contributing code, please follow these guidelines to help us maintain a welcoming and productive environment.</p>"},{"location":"contributing/#how-to-contribute","title":"How to Contribute","text":"<ul> <li>Report Issues: Open an issue for bugs or feature requests. Please provide as much detail as possible.</li> <li>Fork the Repository: Fork the repo, implement your changes, and then create a pull request.</li> <li>Follow Guidelines: Ensure your code adheres to the project's coding standards and includes tests where applicable.</li> </ul>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Our project is committed to fostering a safe and welcoming environment for all contributors. Please review and abide by our Code of Conduct to understand our expectations for community behavior.</p> <p>Thank you for your interest in contributing to <code>mifarepy</code>!</p>"},{"location":"examples/","title":"\ud83d\udcdd Examples","text":""},{"location":"examples/#example-1-authenticating-a-sector-and-reading-from-a-block","title":"Example 1: Authenticating a Sector and Reading from a Block","text":"<p>In this example, we demonstrate how to save the default key, authenticate a specific sector, and then read data from a block within that sector.</p> <pre><code>from mifarepy import Handle, QueryMessage\n\n# Initialize the RFID reader handle on the correct serial port.\nhandle = Handle('/dev/ttyUSB0')\n# Wait for a card to be detected.\nhandle.wait_for_card()\n\n# --- Step 1: Save the Key to the Reader ---\nsector = 2                       # The sector to authenticate.\nkey_type = 0x60                  # Key A (use 0x61 for Key B if required).\ndefault_key = \"FFFFFFFFFFFF\"      # Default key in hexadecimal.\n\n# Build the payload: key type (1 byte), sector (1 byte), followed by key bytes.\nsave_key_data = bytes([key_type, sector]) + bytes.fromhex(default_key)\nhandle.sendmsg(QueryMessage.SAVE_KEY, save_key_data)\nsave_key_ack = handle.readmsg()\nprint(\"SAVE_KEY ACK:\", save_key_ack.data.hex())\n\n# --- Step 2: Authenticate the Sector ---\nauth_data = bytes([key_type, sector])\nhandle.sendmsg(QueryMessage.AUTHENTICATE, auth_data)\nauth_ack = handle.readmsg()\nprint(\"AUTHENTICATE ACK:\", auth_ack.data.hex())\n\n# --- Step 3: Read from a Block in the Authenticated Sector ---\nblock_number = 0  # The block number to read from.\nhandle.sendmsg(QueryMessage.READ_BLOCK, bytes([block_number]))\nblock_response = handle.readmsg()\nprint(\"Block Data:\", block_response.data.hex())\n</code></pre>"},{"location":"examples/#example-2-switching-sectors-and-refreshing-the-card-session","title":"Example 2: Switching Sectors and Refreshing the Card Session","text":"<p>When switching to a new sector, it's important to refresh the card session by sending an ANTI_COLLISION command. This example shows how to do that before authenticating the new sector and reading from a block.</p> <pre><code>from mifarepy import Handle, QueryMessage\n\n# Initialize the RFID reader handle.\nhandle = Handle('/dev/ttyUSB0')\n\n# Assume you have finished operations in the current sector.\n# Now you want to switch to a new sector (e.g., sector 3).\nnew_sector = 3\nkey_type = 0x60                  # Using Key A.\ndefault_key = \"FFFFFFFFFFFF\"      # Default key in hexadecimal.\n\n# --- Step 1: Refresh the Card Session ---\n# When switching sectors, send the ANTI_COLLISION command to re-identify the card.\nhandle.sendmsg(QueryMessage.ANTI_COLLISION, b'')\nanti_collision_response = handle.readmsg(sink_events=True)\nprint(\"ANTI_COLLISION Response:\", anti_collision_response.data.hex())\n\n# --- Step 2: Save the Key for the New Sector ---\nsave_key_data = bytes([key_type, new_sector]) + bytes.fromhex(default_key)\nhandle.sendmsg(QueryMessage.SAVE_KEY, save_key_data)\nsave_key_ack = handle.readmsg()\nprint(\"SAVE_KEY ACK (New Sector):\", save_key_ack.data.hex())\n\n# --- Step 3: Authenticate the New Sector ---\nauth_data = bytes([key_type, new_sector])\nhandle.sendmsg(QueryMessage.AUTHENTICATE, auth_data)\nauth_ack = handle.readmsg()\nprint(\"AUTHENTICATE ACK (New Sector):\", auth_ack.data.hex())\n\n# --- Step 4: Read from a Block in the New Sector ---\nblock_number = 8  # Specify the block number to read from in the new sector.\nhandle.sendmsg(QueryMessage.READ_BLOCK, bytes([block_number]))\nblock_response = handle.readmsg()\nprint(\"Block Data (New Sector):\", block_response.data.hex())\n</code></pre>"},{"location":"installation/","title":"\ud83d\udce5 Installation Guide","text":""},{"location":"installation/#install-from-pypi","title":"Install from PyPI","text":"<pre><code>pip install mifarepy\n</code></pre>"},{"location":"installation/#manual-installation","title":"Manual Installation","text":"<p>Clone the repository and install dependencies manually:</p> <pre><code>git clone https://github.com/AARSOL-Pvt-Ltd/mifarepy.git\ncd mifarepy\npip install -r requirements.txt\n</code></pre>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Ensure you have Python 3.6+ installed.</li> <li>Make sure the <code>pyserial</code> library is available (it\u2019s installed automatically with <code>mifarepy</code> via PyPI).</li> </ul> <p>For additional setup instructions or troubleshooting tips, refer to the API Reference and Usage Guide.</p>"},{"location":"usage/","title":"\ud83d\ude80 Usage Guide","text":"<p>This guide will help you quickly get started with <code>mifarepy</code>, from connecting to your RFID reader to performing basic operations.</p>"},{"location":"usage/#connecting-to-a-reader","title":"Connecting to a Reader","text":"<p>The simplest way to connect to your MIFARE RFID reader is:</p> <pre><code>from mifarepy import Handle\n\n# Initialize the handle with the correct serial port (e.g., '/dev/ttyUSB0' for Linux)\nhandle = Handle('/dev/ttyUSB0')\n# Wait for a card to be detected.\nhandle.wait_for_card()\n# Retrieve the card's serial number as a formatted string\nserial_number = handle.get_sn(as_string=True)\nprint(f'Found card: {serial_number}')\n</code></pre> <p>Note: wait_for_card() also returns the card's serial number, so you can skip the get_sn() call if you only need the serial number.</p>"},{"location":"usage/#retrieving-the-reader-version","title":"Retrieving the Reader Version","text":"<p>You can also query your RFID reader\u2019s version:</p> <pre><code>from mifarepy import Handle\n\n# Initialize the handle with the correct serial port (e.g., '/dev/ttyUSB0' for Linux)\nhandle = Handle('/dev/ttyUSB0')\n# Wait for a card to be detected.\nhandle.wait_for_card()\n# Retrieve the reader's version information\nversion_info = handle.get_version()\nprint('Reader Version:', version_info)\n</code></pre> <p>For full, detailed examples, see the Examples section.</p>"}]}