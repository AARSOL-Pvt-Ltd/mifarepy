{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\udcdd Welcome to mifarepy Documentation \ud83c\udf89","text":"<p>Welcome to the official documentation for mifarepy, the lightweight and user-friendly Python library for interacting with MIFARE\u00ae RFID card readers over serial using the GNetPlus\u00ae protocol.</p>"},{"location":"#table-of-contents","title":"\ud83d\udcd6 Table of Contents","text":"<ol> <li>Introduction </li> <li>Features </li> <li>Getting Started </li> <li>Installation </li> <li>Quickstart </li> <li>Core Concepts </li> <li>Protocol Layer </li> <li>Reader API </li> <li>Detailed Guides </li> <li>API Reference </li> <li>Usage Guide </li> <li>Examples </li> <li>Installation </li> <li>Contributing </li> <li>License </li> </ol>"},{"location":"#introduction","title":"\ud83d\ude80 Introduction","text":"<p><code>mifarepy</code> provides a clear, Pythonic interface to PROMAG, MF5, MF10, and other MIFARE-compatible RFID readers. Whether you are building an access-control system \ud83d\udeaa, an inventory tracker \ud83d\udce6, or simply experimenting with RFID cards \ud83c\udfb4 in your workshop, mifarepy makes it easy to send commands and interpret responses.</p>"},{"location":"#features","title":"\u2728 Features","text":"<ul> <li>\ud83d\udcbe Low-level protocol support: Pack and parse GNetPlus\u00ae messages with CRC  </li> <li>\ud83d\udd0d Automatic card detection: Enable/disable event mode, wait for card arrivals  </li> <li>\ud83e\udde9 Card operations: Read/write single blocks or entire sectors  </li> <li>\u26a1 Bulk reads/writes: Map-based reads across multiple sectors or blocks  </li> <li>\ud83d\udc0d Python 3.6+ support: Works on Linux, macOS, and Windows (via COM ports)  </li> <li>\ud83d\udd27 Extensible and testable: Separation of protocol and device logic for easier testing  </li> </ul>"},{"location":"#getting-started","title":"\ud83c\udfc1 Getting Started","text":""},{"location":"#installation","title":"\ud83d\udce6 Installation","text":"<p>Install the latest stable release from PyPI:</p> <pre><code>pip install mifarepy\n</code></pre> <p>For active development, clone this repository and install in editable mode:</p> <pre><code>git clone https://github.com/SparkDrago05/mifarepy.git\ncd mifarepy_project\npip install -e .\n</code></pre>"},{"location":"#quickstart","title":"\u2699\ufe0f Quickstart","text":"<p>Here is a minimal example to detect a card, read its UID, and fetch a data block:</p> <pre><code>from mifarepy.reader import MifareReader\n\n# 1. Initialize the reader on the serial port\nreader = MifareReader('/dev/ttyUSB0')\n\n# 2. Enable auto-mode and wait for a card\nreader.set_auto_mode(True)\nuid = reader.wait_for_card(timeout=5)\nprint(f\"Card UID: {uid}\")\n\n# 3. Authenticate and read block 4\ndefault_key = bytes.fromhex('FFFFFFFFFFFF')\nreader.authenticate_sector(sector=1, key=default_key)\nblock4 = reader.read_block(4)\nprint(f\"Block 4 (hex): {block4.hex()}\")\n</code></pre>"},{"location":"#core-concepts","title":"\ud83e\udde0 Core Concepts","text":""},{"location":"#protocol-layer","title":"\ud83d\udd17 Protocol Layer","text":"<p>All GNetPlus\u00ae message framing, CRC calculations, and exceptions are implemented in <code>mifarepy/protocol.py</code>:</p> <ul> <li><code>Message</code>: Base class, handles SOH, addressing, function codes, data, CRC.  </li> <li><code>QueryMessage</code>: Subclass with constants for each command (e.g., <code>REQUEST</code>, <code>READ_BLOCK</code>).  </li> <li><code>ResponseMessage</code>: Parses incoming replies, detects <code>ACK</code>, <code>NAK</code>, and event notifications.  </li> <li><code>gencrc()</code>: Utility to compute 16-bit CRC as per the protocol specification.  </li> </ul>"},{"location":"#reader-api","title":"\ud83d\udce1 Reader API","text":"<p>The high-level interface lives in <code>mifarepy/reader.py</code>:</p> <ul> <li><code>MifareReader</code>: Connects to a serial port, sends queries, and returns parsed responses.  </li> <li>Methods include: </li> <li><code>get_version()</code> \ud83d\udd16  </li> <li><code>set_auto_mode()</code> / <code>wait_for_card()</code> \u23f1\ufe0f  </li> <li><code>get_sn()</code> \ud83c\udd94  </li> <li><code>authenticate_sector()</code> \ud83d\udd10  </li> <li><code>read_block()</code> / <code>write_block()</code> \ud83d\udcda  </li> <li><code>read_sector()</code> / <code>write_sector()</code> \ud83d\udd04  </li> </ul> <p>All methods raise <code>GNetPlusError</code> or <code>InvalidMessage</code> on protocol or hardware errors.</p>"},{"location":"#detailed-guides","title":"\ud83d\udcda Detailed Guides","text":"<ul> <li>API Reference: Full descriptions of classes and functions \u2014 see [api.md].  </li> <li>Usage Guide: Common workflows and best practices \u2014 see [usage.md].  </li> <li>Examples: Real-world code samples \u2014 see [examples.md].  </li> <li>Configuration and Troubleshooting: Tips for serial-port permissions, timeouts, and error recovery.  </li> </ul>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>We welcome contributions! Please read our contributing guidelines for details on setting up your development environment, code style, and submitting pull requests. \u2764\ufe0f</p>"},{"location":"#license","title":"\ud83c\udff7\ufe0f License","text":"<p><code>mifarepy</code> is released under the LGPL v3.0 or later. See the LICENSE file for full terms.</p>"},{"location":"CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and maintainers pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery and sexual attention or advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject contributions that are not aligned with this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at <code>huzaifa.farooq@aarsol.com</code>. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community members are expected to abide by this Code of Conduct. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project\u2019s leadership.</p>"},{"location":"CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p>"},{"location":"api/","title":"API Reference","text":"<p>This document provides an in-depth reference for every public class, function, and method in the mifarepy library, complete with parameter descriptions, return values, exceptions raised, and detailed behavior narratives.</p>"},{"location":"api/#package-structure","title":"Package Structure","text":"<pre><code>mifarepy/\n\u251c\u2500\u2500 protocol.py      # Core message framing, CRC, and error classes\n\u2514\u2500\u2500 reader.py        # High-level MifareReader interface and card operations\n</code></pre> <p>Import core components:</p> <pre><code>import mifarepy\nfrom mifarepy.protocol import (\n    gencrc,\n    Message,\n    QueryMessage,\n    ResponseMessage,\n    InvalidMessage,\n    GNetPlusError\n)\nfrom mifarepy.reader import MifareReader\n</code></pre>"},{"location":"api/#protocolpy","title":"<code>protocol.py</code>","text":""},{"location":"api/#gencrcmsg_bytes-bytes-int","title":"<code>gencrc(msg_bytes: bytes) -&gt; int</code>","text":"<p>Description: Calculates the 16-bit CRC (Cyclic Redundancy Check) for a given sequence of bytes, following the GNetPlus\u00ae protocol specification. This checksum is appended to each message to ensure data integrity.</p> <ul> <li>Parameters:</li> <li><code>msg_bytes</code> (<code>bytes</code>): The header and payload bytes over which to compute the CRC (Exclude SOH and the trailing CRC field).</li> <li>Returns:</li> <li>(<code>int</code>) CRC value ranging from <code>0</code> to <code>0xFFFF</code>.</li> <li>Raises: None.</li> </ul>"},{"location":"api/#class-invalidmessageexception","title":"<code>class InvalidMessage(Exception)</code>","text":"<p>Description: Thrown during message parsing when the data read from the serial port is malformed, incomplete, or fails the CRC check.</p> <ul> <li>Raised When:</li> <li>The Start-of-Header (SOH) byte is incorrect.</li> <li>The header or payload length is less than expected.</li> <li>CRC validation fails.</li> </ul>"},{"location":"api/#class-gnetpluserrorexception","title":"<code>class GNetPlusError(Exception)</code>","text":"<p>Description: Represents a protocol-level or device error signaled by a Negative Acknowledge (NAK) from the reader.</p> <ul> <li>Raised When: A <code>ResponseMessage</code> with <code>function == ResponseMessage.NAK</code> is received. The exception carries the raw NAK payload for diagnostics.</li> </ul>"},{"location":"api/#class-message","title":"<code>class Message</code>","text":"<p>Description: Base class encapsulating the raw binary format of any GNetPlus\u00ae message (both queries and responses). Handles packing to bytes and unpacking from bytes with CRC.</p>"},{"location":"api/#constructor","title":"Constructor","text":"<p><pre><code>Message(address: int, function: int, data: bytes)\n</code></pre> - Parameters:   - <code>address</code> (<code>int</code>): The 8-bit device address (commonly <code>0</code>).   - <code>function</code> (<code>int</code>): The 8-bit function or command code.   - <code>data</code> (<code>bytes</code>): Payload data. - Behavior: Stores inputs; used by <code>__bytes__</code> and <code>readfrom</code> methods.</p>"},{"location":"api/#__bytes__self-bytes","title":"<code>__bytes__(self) -&gt; bytes</code>","text":"<p>Description: Serializes the <code>Message</code> into the wire format:</p> <pre><code>[SOH=0x01][address][function][length][data...][CRC-high][CRC-low]\n</code></pre> <ul> <li>Returns: A <code>bytes</code> object ready to write to a serial port.</li> </ul>"},{"location":"api/#classmethod-readfromcls-serial_port-message","title":"<code>@classmethod readfrom(cls, serial_port) -&gt; Message</code>","text":"<p>Description: Reads raw bytes from a <code>serial_port</code> instance and constructs a <code>Message</code> object, validating framing and CRC.</p> <ul> <li>Parameters:</li> <li><code>serial_port</code>: An object with a <code>.read(n)</code> method (e.g., <code>serial.Serial</code>).</li> <li>Behavior:</li> <li>Reads 1 byte for SOH, 3 bytes for header. Validates SOH.</li> <li>Extracts <code>address</code>, <code>function</code>, and <code>length</code>.</li> <li>Reads <code>length</code> bytes of payload.</li> <li>Reads 2-byte CRC, computes expected CRC via <code>gencrc</code>.</li> <li>Raises <code>InvalidMessage</code> if any step fails.</li> <li>Returns: A <code>Message</code> instance with <code>.address</code>, <code>.function</code>, <code>.data</code> set.</li> <li>Raises: <code>InvalidMessage</code> on framing, length, or CRC errors.</li> </ul>"},{"location":"api/#class-querymessagemessage","title":"<code>class QueryMessage(Message)</code>","text":"<p>Description: Subclass of <code>Message</code> defining constants for all supported outgoing commands in the GNetPlus\u00ae protocol.</p> Constant Hex Value Description <code>POLLING</code> <code>0x00</code> Ping the reader to check connectivity <code>GET_VERSION</code> <code>0x01</code> Request reader firmware version <code>AUTO_MODE</code> <code>0x3F</code> Enable/disable automatic card event reporting <code>REQUEST</code> <code>0x20</code> Begin anti-collision to detect one card UID <code>ANTI_COLLISION</code> <code>0x21</code> Complete anti-collision, retrieve full UID <code>SELECT_CARD</code> <code>0x22</code> Select a specific card after UID retrieval <code>AUTHENTICATE</code> <code>0x23</code> Authenticate a sector using loaded key <code>READ_BLOCK</code> <code>0x24</code> Read a single 16-byte block <code>WRITE_BLOCK</code> <code>0x25</code> Write a single 16-byte block <code>SAVE_KEY</code> <code>0x2B</code> Load a 6-byte MIFARE key into reader RAM <p>Use these as: <pre><code>msg = QueryMessage(address, QueryMessage.READ_BLOCK, payload)\n</code></pre></p>"},{"location":"api/#class-responsemessagemessage","title":"<code>class ResponseMessage(Message)</code>","text":"<p>Description: Subclass for replies from the reader. Interprets acknowledgement, errors, and event notifications.</p> Constant Hex Value Description <code>ACK</code> <code>0x06</code> Positive acknowledgement <code>NAK</code> <code>0x15</code> Negative acknowledgement (error) <code>EVN</code> <code>0x12</code> Event notification (e.g., card arrival)"},{"location":"api/#to_errorself-optionalgnetpluserror","title":"<code>to_error(self) -&gt; Optional[GNetPlusError]</code>","text":"<p>Description: Converts a NAK response into a <code>GNetPlusError</code>. If the response is not NAK, returns <code>None</code>.</p> <ul> <li>Returns: A <code>GNetPlusError</code> instance for NAK responses, or <code>None</code> otherwise.</li> </ul>"},{"location":"api/#readerpy","title":"reader.py","text":""},{"location":"api/#class-mifarereader","title":"<code>class MifareReader</code>","text":"<p>Description: High-level interface encapsulating serial communication and common card operations. Simplifies sending commands, parsing responses, and handling errors.</p>"},{"location":"api/#constructor_1","title":"Constructor","text":"<p><pre><code>MifareReader(\n    port: str = '/dev/ttyUSB0',\n    baudrate: int = 19200,\n    address: int = 0,\n    **kwargs\n)\n</code></pre> - Parameters:   - <code>port</code> (<code>str</code>): Path to serial device or COM port.   - <code>baudrate</code> (<code>int</code>): Communication speed (default <code>19200</code>).   - <code>address</code> (<code>int</code>): Reader device address (usually 0).   - <code>**kwargs</code>: Additional settings for <code>serial.Serial</code> (e.g., <code>timeout</code>). - Behavior: Opens serial port; raises <code>RuntimeError</code> on failure.</p>"},{"location":"api/#sendmsgself-function-int-data-bytes-b-none","title":"<code>sendmsg(self, function: int, data: bytes = b'') -&gt; None</code>","text":"<p>Description: Packages and sends a <code>QueryMessage</code> to the reader.</p> <ul> <li>Parameters:</li> <li><code>function</code> (<code>int</code>): One of <code>QueryMessage</code> constants.</li> <li><code>data</code> (<code>bytes</code>): Optional payload.</li> <li>Behavior: Serializes and writes raw bytes to the serial port.</li> <li>Raises: Propagates exceptions from <code>serial.write()</code>.</li> </ul>"},{"location":"api/#readmsgself-sink_events-bool-false-responsemessage","title":"<code>readmsg(self, sink_events: bool = False) -&gt; ResponseMessage</code>","text":"<p>Description: Reads and returns the next meaningful response, optionally skipping event notifications.</p> <ul> <li>Parameters:</li> <li><code>sink_events</code> (<code>bool</code>): If <code>True</code>, ignore <code>EVN</code> messages.</li> <li>Behavior: Loops on <code>ResponseMessage.readfrom</code>, raises <code>GNetPlusError</code> on NAK.</li> <li>Returns: A <code>ResponseMessage</code> instance.</li> <li>Raises: <code>GNetPlusError</code>, <code>InvalidMessage</code>.</li> </ul>"},{"location":"api/#get_versionself-str","title":"<code>get_version(self) -&gt; str</code>","text":"<p>Description: Requests and returns the reader\u2019s firmware version.</p> <ul> <li>Behavior: Sends <code>GET_VERSION</code>, reads response, decodes to string.</li> <li>Returns: Version string (e.g., <code>\"v1.2.3\"</code>).</li> <li>Raises: <code>GNetPlusError</code>, <code>InvalidMessage</code>.</li> </ul>"},{"location":"api/#set_auto_modeself-enable-bool-true-none","title":"<code>set_auto_mode(self, enable: bool = True) -&gt; None</code>","text":"<p>Description: Toggles automatic card event reporting mode.</p> <ul> <li>Parameters:</li> <li><code>enable</code> (<code>bool</code>): <code>True</code> to enable, <code>False</code> to disable.</li> <li>Behavior: Sends <code>AUTO_MODE</code> with payload <code>\\x01</code>/<code>\\x00</code>, validates echo.</li> <li>Raises: <code>GNetPlusError</code> on mismatched response.</li> </ul>"},{"location":"api/#wait_for_cardself-timeout-int-10-optionalstr","title":"<code>wait_for_card(self, timeout: int = 10) -&gt; Optional[str]</code>","text":"<p>Description: Blocks until a card arrives or timeout is reached.</p> <ul> <li>Parameters:</li> <li><code>timeout</code> (<code>int</code>): Seconds to wait.</li> <li>Behavior: Enables auto mode, tries immediate <code>get_sn</code>, then listens for EVN, returns UID.</li> <li>Returns: Card UID string or <code>None</code>.</li> <li>Raises: <code>TimeoutError</code>, <code>GNetPlusError</code>, <code>InvalidMessage</code>.</li> </ul>"},{"location":"api/#get_snself-endian-str-little-as_string-bool-true-unionstr-int","title":"<code>get_sn(self, endian: str = 'little', as_string: bool = True) -&gt; Union[str, int]</code>","text":"<p>Description: Retrieves the card\u2019s unique serial number (UID).</p> <ul> <li>Parameters:</li> <li><code>endian</code> (<code>'little'</code> or <code>'big'</code>): Byte order.</li> <li><code>as_string</code> (<code>bool</code>): Return hex string if <code>True</code>, else integer.</li> <li>Behavior: Sends <code>REQUEST</code>/<code>ANTI_COLLISION</code>, unpacks UID.</li> <li>Returns: UID as <code>\"0x...\"</code> or int.</li> <li>Raises: <code>GNetPlusError</code>, <code>InvalidMessage</code>.</li> </ul>"},{"location":"api/#authenticate_sectorself-sector-int-key-bytes-key_type-str-a-none","title":"<code>authenticate_sector(self, sector: int, key: bytes, key_type: str = 'A') -&gt; None</code>","text":"<p>Description: Loads and authenticates a MIFARE key for the specified sector.</p> <ul> <li>Parameters:</li> <li><code>sector</code> (<code>int</code>): Sector index (0\u201315).</li> <li><code>key</code> (<code>bytes</code>): 6-byte MIFARE key.</li> <li><code>key_type</code> (<code>'A'</code> or <code>'B'</code>): Key slot selection.</li> <li><code>timeout</code> (<code>int</code>): Timeout in seconds for reader responses.</li> <li><code>flush</code> (<code>bool</code>): Whether to flush the input buffer before reading responses.</li> <li>Behavior: Validates params, sends <code>SAVE_KEY</code> then <code>AUTHENTICATE</code>, checks ACKs.</li> <li>Raises: <code>ValueError</code>, <code>GNetPlusError</code>, <code>InvalidMessage</code>.</li> </ul>"},{"location":"api/#read_blockself-block-int-raw-bool-false-bytes","title":"<code>read_block(self, block: int, raw: bool = False) -&gt; bytes</code>","text":"<p>Description: Reads exactly 16 bytes from a specific memory block.</p> <ul> <li>Parameters:</li> <li><code>block</code> (<code>int</code>): Block number (0\u201363).</li> <li>Behavior: Sends <code>READ_BLOCK</code>, receives data payload.</li> <li>Returns: 16 bytes.</li> <li>Raises: <code>GNetPlusError</code>, <code>InvalidMessage</code>.</li> </ul>"},{"location":"api/#write_blockself-block-int-data-unionstr-bytes-none","title":"<code>write_block(self, block: int, data: Union[str, bytes]) -&gt; None</code>","text":"<p>Description: Writes exactly 16 bytes or 32 bit hex to a specific block.</p> <ul> <li>Parameters:</li> <li><code>block</code> (<code>int</code>): Block number.</li> <li><code>data</code> (<code>bytes</code>): Must be length 16 bytes.</li> <li>Behavior: Validates length, sends <code>WRITE_BLOCK</code>, confirms ACK.</li> <li>Raises: <code>ValueError</code>, <code>GNetPlusError</code>, <code>InvalidMessage</code>.</li> </ul>"},{"location":"api/#read_sectorself-raw-bool-false-combine-bool-false-uniondictint-unionstr-bytes-unionstr-bytes","title":"<code>read_sector(self, raw: bool = False, combine: bool = False) -&gt; Union[Dict[int, Union[str, bytes]], Union[str, bytes]]</code>","text":"<p>Description: Reads blocks <code>0,1,2</code> of the current sector and returns a mapping or concatenated data.</p> <ul> <li>Parameters:</li> <li><code>sector</code> (<code>int</code>): Sector index.</li> <li>Behavior: Calls <code>read_block</code> for offsets 0\u20133, returns dict.</li> <li>Returns: <code>{block: data} or combined data byte or hex</code>.</li> <li>Raises: <code>GNetPlusError</code>.</li> </ul>"},{"location":"api/#write_sectorself-data-unionstr-bytes-dictint-unionstr-bytes-none","title":"<code>write_sector(self, data: Union[str, bytes, Dict[int, Union[str, bytes]]]) -&gt; None</code>","text":"<p>Description: Writes multiple blocks within one sector using a dictionary.</p> <ul> <li>Parameters:</li> <li><code>sector</code> (<code>int</code>): Sector index.</li> <li><code>data_blocks</code> (<code>Dict[int, bytes]</code>): Map of block offsets to 16-byte data.<ul> <li>bytes/str length 16: writes that blob to blocks 0,1,2.</li> <li>bytes/str length 48: splits into three chunks for blocks 0\u20132.</li> <li>dict {block:data}: dict mapping blocks 0\u20132 to data blobs and 3 for trailing block.</li> </ul> </li> <li>Behavior: Iterates and calls <code>write_block</code> for each entry.</li> <li>Raises: <code>ValueError</code>, <code>GNetPlusError</code>, <code>InvalidMessage</code>.</li> </ul>"},{"location":"api/#read_blocksself-mapping-dictint-listint-raw-bool-false-combine-bool-false-keys-unionbytes-dictint-bytes-none-key_types-unionstr-dictint-str-a-timeout-unionfloat-dictint-float-10-flush-unionbool-dictint-bool-true-uniondictint-dictint-unionstr-bytes-unionstr-bytes-uniondictint-dictint-unionstr-bytes-unionstr-bytes","title":"<code>read_blocks(self, mapping: Dict[int, List[int]], raw: bool = False, combine: bool = False, keys: Union[bytes, Dict[int, bytes]] = None, key_types: Union[str, Dict[int, str]] = 'A', timeout: Union[float, Dict[int, float]] = 1.0, flush: Union[bool, Dict[int, bool]] = True) -&gt; Union[Dict[int, Dict[int, Union[str, bytes]]], Union[str, bytes]]) -&gt; Union[Dict[int, Dict[int, Union[str, bytes]]], Union[str, bytes]]</code>","text":"<p>Description: Read multiple blocks across sectors based on a sector-&gt;block-offsets mapping, optionally combining them and authenticating per sector with either a single key for all sectors or individual keys per sector.</p> <ul> <li>Parameters:</li> <li><code>mapping</code> (<code>dict</code>): Dict where keys are sector numbers and values are lists of block offsets (0-3).</li> <li><code>raw</code> (<code>bool</code>): If True, returns bytes; otherwise hex strings.</li> <li><code>combine</code> (<code>bool</code>): If True, returns concatenated data across blocks as a single bytes or hex string.</li> <li><code>keys</code> (<code>bytes or doct</code>): Optional 6-byte key or dict mapping sector-&gt;key bytes.</li> <li><code>key_types</code> (<code>str or dict</code>): 'A'/'B' or dict mapping sector-&gt;'A'/'B'.</li> <li><code>timeout</code> (<code>float or dict</code>): Timeout in seconds or dict mapping sector-&gt;timeout.</li> <li><code>flush</code> (<code>bool or dict</code>): Whether to flush input buffer or dict mapping sector-&gt;flush flag.</li> <li>Behavior: Returns Nested dict mapping sector -&gt; {offset: data}, or combined bytes/hex.</li> <li>Raises: <code>ValueError</code>, <code>GNetPlusError</code>.</li> </ul>"},{"location":"api/#write_blocksself-mapping-dictint-unionbytes-str-dictint-unionstr-bytes-keys-unionbytes-dictint-bytes-none-key_types-unionstr-dictint-str-a-timeout-unionfloat-dictint-float-10-flush-unionbool-dictint-bool-true-none","title":"<code>write_blocks(self, mapping: Dict[int, Union[bytes, str, Dict[int, Union[str, bytes]]]], keys: Union[bytes, Dict[int, bytes]] = None, key_types: Union[str, Dict[int, str]] = 'A', timeout: Union[float, Dict[int, float]] = 1.0, flush: Union[bool, Dict[int, bool]] = True) -&gt; None</code>","text":"<p>Description: Write multiple blocks across sectors, supporting a mix of: - sector -&gt; blob (bytes or hex-string) (writes that blob to all 4 blocks via write_sector) - sector -&gt; {block: data, \u2026} (writes per\u2010block via write_block)</p> <p>optionally authenticating per sector with either a global key or per-sector keys.</p> <ul> <li>Parameters:</li> <li><code>mapping</code> (<code>dict</code>): Dict where keys are sector numbers and values are either dict mapping block (0-3) to data or a single blob for the whole sector.</li> <li><code>keys</code> (<code>bytes or doct</code>): Optional 6-byte key or dict mapping sector-&gt;key bytes.</li> <li><code>key_types</code> (<code>str or dict</code>): 'A'/'B' or dict mapping sector-&gt;'A'/'B'.</li> <li><code>timeout</code> (<code>float or dict</code>): Timeout in seconds or dict mapping sector-&gt;timeout.</li> <li><code>flush</code> (<code>bool or dict</code>): Whether to flush input buffer or dict mapping sector-&gt;flush flag.</li> <li>Behavior: Writes data in the given blocks handling refreshing of card before authentication for new sector.</li> <li>Raises: <code>ValueError</code>, <code>GNetPlusError</code>.</li> </ul>"},{"location":"api/#exception-summary","title":"Exception Summary","text":"<p>All methods may raise:</p> <ul> <li><code>InvalidMessage</code>: Frame/CRC parsing errors.</li> <li><code>GNetPlusError</code>: Device-signaled errors (NAK).</li> <li><code>RuntimeError</code>: Serial port failures.</li> <li><code>ValueError</code>: Invalid arguments.</li> <li><code>TimeoutError</code>: For <code>wait_for_card</code> timeouts.</li> </ul> <p>For real-world code examples using these APIs, see examples.</p>"},{"location":"contributing/","title":"\ud83e\udd1d Contributing to <code>mifarepy</code>","text":"<p>Thank you for considering a contribution to mifarepy! We value all forms of contributions\u2014bug reports, feature requests, documentation improvements, and code enhancements. To make collaboration smooth and efficient, please follow the guidelines below.</p>"},{"location":"contributing/#code-of-conduct","title":"\ud83d\udccb Code of Conduct","text":"<p>Our community is governed by a Code of Conduct. By participating, you agree to uphold its principles and treat everyone with respect and courtesy.</p>"},{"location":"contributing/#get-started","title":"\ud83d\udee0 Get Started","text":""},{"location":"contributing/#1-report-issues","title":"1. Report Issues","text":"<ul> <li>Use GitHub Issues to report bugs or request features.</li> <li>When filing an issue:</li> <li>Provide a clear title and description.</li> <li>Include steps to reproduce, expected vs. actual behavior, and environment details.</li> <li>Attach logs, screenshots, or minimal code snippets if helpful.</li> </ul>"},{"location":"contributing/#2-fork-clone","title":"2. Fork &amp; Clone","text":"<pre><code>git clone https://github.com/SparkDrago05/mifarepy.git\ncd mifarepy\ngit checkout -b feature/your-topic\n</code></pre> <ul> <li>Use a descriptive branch name prefixed with <code>feature/</code>, <code>fix/</code>, or <code>docs/</code>.</li> </ul>"},{"location":"contributing/#3-set-up-development-environment","title":"3. Set Up Development Environment","text":"<pre><code>python3 -m venv venv\nsource venv/bin/activate    # Windows: venv\\Scripts\\activate\npip install -e .\npip install -r requirements-dev.txt\n</code></pre> <ul> <li>This installs mifarepy in editable mode and developer dependencies (linting, testing).</li> </ul>"},{"location":"contributing/#writing-code","title":"\ud83d\udea7 Writing Code","text":"<ul> <li>Follow PEP8 style; project uses Pycharm (auto-format) and Flake8 (linting).</li> <li>Write clear, modular code with meaningful names and docstrings.</li> <li>Add or update pytest tests under <code>tests/</code> to cover new behavior.</li> <li>Ensure all tests pass:</li> </ul> <pre><code>pytest --maxfail=1 --disable-warnings -q\n</code></pre> <ul> <li>Maintain or improve code coverage, especially for critical paths.</li> </ul>"},{"location":"contributing/#commits-pull-requests","title":"\ud83d\udcac Commits &amp; Pull Requests","text":""},{"location":"contributing/#commit-messages","title":"Commit Messages","text":"<ul> <li>Follow Conventional Commits:</li> <li><code>feat: add new reader method</code></li> <li><code>fix: correct CRC calculation</code></li> <li><code>docs: update usage guide</code></li> <li><code>chore: bump version to 1.2.0</code></li> </ul>"},{"location":"contributing/#pull-request","title":"Pull Request","text":"<ul> <li>Push your branch and open a PR against the <code>main</code> branch.</li> <li>In the PR description:</li> <li>Summarize the change, motivation, and any linking issue.</li> <li>List manual testing steps, if applicable.</li> <li>Respond to review feedback and update your PR until approved.</li> </ul>"},{"location":"contributing/#after-merge","title":"\u2705 After Merge","text":"<ul> <li>Celebrate! \ud83c\udf89 Your contributions help improve mifarepy for everyone.</li> <li>Keep your fork and branches tidy by deleting merged branches.</li> </ul>"},{"location":"contributing/#license","title":"\ud83d\udcdc License","text":"<p>By contributing, you agree that your changes will be licensed under the project's LGPL v3.0 or later.</p>"},{"location":"examples/","title":"\ud83d\udd0d Examples","text":"<p>These examples demonstrate common mifarepy workflows using the <code>MifareReader</code> API.</p>"},{"location":"examples/#1-detect-and-read-card-uid","title":"1\ufe0f\u20e3 Detect and Read Card UID","text":"<pre><code>from mifarepy import MifareReader\n\n# 1. Initialize reader\nreader = MifareReader(port='/dev/ttyUSB0')\n\n# 2. Enable auto\u2010mode and wait for a card\nreader.set_auto_mode(True)\ntry:\n    uid = reader.wait_for_card(timeout=5)\n    print(f\"\u2705 Detected card UID: {uid}\")\nexcept TimeoutError:\n    print(\"\u23f0 No card detected within 5 seconds.\")\n</code></pre> <p>What\u2019s happening: - <code>set_auto_mode(True)</code>: Reader emits events when cards enter field. - <code>wait_for_card()</code>: Blocks until a card is seen or timeout.</p>"},{"location":"examples/#2-authenticate-sector-read-block","title":"2\ufe0f\u20e3 Authenticate Sector &amp; Read Block","text":"<pre><code>from mifarepy import MifareReader\n\nreader = MifareReader('/dev/ttyUSB0')\n\n# Default MIFARE Key A\nkey_a = bytes.fromhex('FFFFFFFFFFFF')\nsector = 1\nblock = 0  # first block in sector 1\n\n# Authenticate sector\nreader.authenticate_sector(sector=sector, key=key_a, key_type='A')\n\n# Read block data\ndata = reader.read_block(block)\nprint(f\"Block {block} data: {data.hex()}\")\n</code></pre> <p>Details: - <code>authenticate_sector()</code>: Loads and uses Key A to unlock sector. - <code>read_block()</code>: Reads 16 bytes from specified block index.</p>"},{"location":"examples/#3-write-to-a-block","title":"3\ufe0f\u20e3 Write to a Block","text":"<pre><code>from mifarepy import MifareReader\n\nreader = MifareReader('/dev/ttyUSB0')\n\n# Authenticate first\nreader.authenticate_sector(sector=1, key=key_a)\n\n# Prepare payload\npayload = bytes(range(16))  # 0x00..0x0F\nblock = 1 # Second block in Sector 1\n\n# Write and verify\nreader.write_block(block, payload)\nprint(f\"\u270d\ufe0f Wrote to block {block} successfully.\")\n</code></pre> <p>Note: Data must be exactly 16 bytes.</p>"},{"location":"examples/#4-read-entire-sector","title":"4\ufe0f\u20e3 Read Entire Sector","text":"<pre><code>from mifarepy import MifareReader\n\nreader = MifareReader('/dev/ttyUSB0')\nreader.authenticate_sector(sector=2, key=key_a)\n\nsector_data = reader.read_sector(sector=2)\nfor block, blk_data in sector_data.items():\n    print(f\"Block {block}: {blk_data.hex()}\")\n</code></pre> <ul> <li>Returns a mapping of offsets (0\u20133) to block bytes.</li> </ul>"},{"location":"examples/#5-write-multiple-blocks-in-sector","title":"5\ufe0f\u20e3 Write Multiple Blocks in Sector","text":"<pre><code>from mifarepy import MifareReader\n\nreader = MifareReader('/dev/ttyUSB0')\nreader.authenticate_sector(sector=2, key=key_a)\n\nupdates = {\n    0: bytes([0xAA] * 16),  # First Block of Sector 2 \n    2: bytes([0xBB] * 16)   # Third Block of Sector 2\n}\nreader.write_sector(sector=2, data_blocks=updates)\nprint(\"\ud83d\udd27 Sector 2 updated on blocks 0 and 2.\")\n</code></pre> <p>Data for unspecified offsets remains unchanged.</p>"},{"location":"examples/#6-bulk-mapping-read-and-write","title":"6\ufe0f\u20e3 Bulk Mapping: Read and Write","text":"<pre><code>from mifarepy import MifareReader\n\nreader = MifareReader('/dev/ttyUSB0')\n\n# Define mapping: sector \u2192 list of offsets\nread_map = {1: [0,1], 3: [2,3]}\n\n# Optionally provide per-sector keys\nkeys = {1: key_a, 3: key_a}\n\ndata = reader.read_blocks(mapping=read_map, raw=False, combine=False, keys=keys)\nprint(data)\n\n# Write mapping: full blob for sector 1 and dict for sector 3\nwrite_map = {\n    1: bytes(range(48)),             # three-block blob\n    3: {0: b'HELLO-R3'*2, 3: b'BYE-R3'*2}\n}\nreader.write_blocks(mapping=write_map, keys=keys)\nprint(\"\ud83d\ude80 Bulk operations complete.\")\n</code></pre> <ul> <li><code>read_blocks</code>: Reads arbitrary sets of blocks across sectors.</li> <li><code>write_blocks</code>: Writes sector-wide or per-block based on mapping.</li> </ul> <p>For more details, see usage and api.</p>"},{"location":"installation/","title":"\ud83d\udce5 Installation Guide","text":"<p>This guide covers different ways to install mifarepy and its prerequisites.</p>"},{"location":"installation/#prerequisites","title":"\u2699\ufe0f Prerequisites","text":"<ul> <li>Python version: 3.7 or newer \ud83d\udc0d  </li> <li>pyserial: Installed automatically via PyPI, but ensure no conflicts.  </li> <li>Permissions (Linux): Add your user to the <code>dialout</code> group to access serial ports:   <pre><code>sudo usermod -aG dialout $USER\n</code></pre>   Then log out and back in, or restart.</li> <li>Windows: Identify your COM port (e.g., <code>COM3</code>) and install the driver if needed.</li> </ul>"},{"location":"installation/#install-from-pypi","title":"\ud83d\udce6 Install from PyPI","text":"<p>The simplest way is via pip:</p> <pre><code>pip install mifarepy\n</code></pre> <p>This installs the latest stable release and its dependencies (including <code>pyserial</code>).</p>"},{"location":"installation/#editable-development-install","title":"\ud83d\udd27 Editable / Development Install","text":"<p>If you plan to develop or contribute to mifarepy, install in editable mode:</p> <pre><code>git clone https://github.com/SparkDrago05/mifarepy.git\ncd mifarepy\npip install -e .\n</code></pre> <p>This links the repository into your environment so changes are picked up immediately.</p>"},{"location":"installation/#manual-source-install","title":"\ud83d\udcc1 Manual / Source Install","text":"<p>For environments without PyPI access, install from source:</p> <pre><code>git clone https://github.com/SparkDrago05/mifarepy.git\ncd mifarepy\n# Create a virtual environment (optional but recommended)\npython3 -m venv venv\nsource venv/bin/activate  # Windows: venv\\Scripts\\activate\npip install -r requirements.txt\n</code></pre> <p>Note: Ensure <code>requirements.txt</code> is up to date. Alternatively, you can use <code>pip install -e .</code> as above.</p>"},{"location":"installation/#using-pyprojecttoml-pep-517518","title":"\ud83d\udc0d Using pyproject.toml (PEP 517/518)","text":"<p>If you use modern tooling:</p> <pre><code>pip install build\npython -m build  # will generate wheel and sdist in dist/\npip install dist/mifarepy-*.whl\n</code></pre>"},{"location":"installation/#verify-installation","title":"\ud83d\udd0d Verify Installation","text":"<pre><code>python -c \"import mifarepy; print(mifarepy.__version__)\"\n</code></pre> <p>You should see the installed version number, confirming a successful install.</p> <p>For further configuration and advanced usage, see the API Reference and Usage Guide. \ud83c\udf89</p>"},{"location":"usage/","title":"\ud83d\udcd8 Usage Guide \ud83d\ude80","text":"<p>This guide walks you through common workflows in mifarepy: connecting to your reader, detecting cards, reading/writing blocks and sectors, bulk operations, and error handling.</p>"},{"location":"usage/#prerequisites","title":"\ud83d\udd27 Prerequisites","text":"<ul> <li>Python 3.6 or newer \ud83d\udc0d</li> <li><code>pyserial</code> installed (automatically with <code>pip install mifarepy</code>)</li> <li>A supported MIFARE\u00ae reader (PROMAG PCR310U, MF5, MF10, etc.) connected via USB-to-serial or COM port \ud83d\udd0c</li> <li>Appropriate permissions (e.g., add your user to <code>dialout</code> on Linux) \ud83d\udee0\ufe0f</li> </ul>"},{"location":"usage/#1-connecting-to-the-reader","title":"1\ufe0f\u20e3 Connecting to the Reader","text":"<pre><code>from mifarepy.reader import MifareReader\n\n# Replace '/dev/ttyUSB0' with your port (e.g., 'COM3' on Windows)\nreader = MifareReader(port='/dev/ttyUSB0', baudrate=19200)\n</code></pre> <ul> <li><code>port</code>: Serial device path.</li> <li><code>baudrate</code>: Communication speed (default <code>19200</code>).</li> <li>Raises <code>RuntimeError</code> \u274c if the port cannot be opened.</li> </ul>"},{"location":"usage/#2-discovering-cards","title":"2\ufe0f\u20e3 Discovering Cards","text":""},{"location":"usage/#21-enable-event-mode-and-wait","title":"2.1 \ud83d\udd04 Enable Event Mode and Wait","text":"<pre><code># Turn on automatic card detection\nreader.set_auto_mode(True)\n\n# Block up to 10 seconds for a card\nuid = reader.wait_for_card(timeout=10)\nif uid:\n    print(f\"\u2705 Card detected: {uid}\")\nelse:\n    print(\"\u23f0 No card detected within timeout.\")\n</code></pre> <ul> <li><code>set_auto_mode(True)</code>: Enables event notifications \ud83d\udd14.</li> <li><code>wait_for_card(timeout)</code>: Returns UID string or raises <code>TimeoutError</code>.</li> </ul>"},{"location":"usage/#22-polling-for-uid-directly","title":"2.2 \ud83d\udcf6 Polling for UID Directly","text":"<pre><code># Manual polling\nuid = reader.get_sn(endian='little', as_string=True)\nprint(f\"\ud83c\udfb4 Card UID: {uid}\")\n</code></pre> <ul> <li><code>get_sn</code>: Anti-collision sequence; returns hex string or integer \ud83d\udd22.</li> <li><code>endian</code>: Byte order; <code>as_string</code> toggles return type.</li> </ul>"},{"location":"usage/#3-reading-and-writing-a-single-block","title":"3\ufe0f\u20e3 Reading and Writing a Single Block","text":""},{"location":"usage/#31-authenticate-a-sector","title":"3.1 \ud83d\udd10 Authenticate a Sector","text":"<pre><code># MIFARE Classic default Key A\ndefault_key = bytes.fromhex('FFFFFFFFFFFF')\nreader.authenticate_sector(sector=1, key=default_key, key_type='A')\n</code></pre> <ul> <li><code>sector</code>: 0\u201315 (for 1K cards).</li> <li><code>key_type</code>: <code>'A'</code> or <code>'B'</code>.</li> <li>Raises <code>ValueError</code>, <code>GNetPlusError</code> on failure.</li> </ul>"},{"location":"usage/#32-read-16-bytes","title":"3.2 \ud83d\udcd6 Read 16 Bytes","text":"<pre><code>data = reader.read_block(block=4)\nprint(\"Block 4 data:\", data.hex())\n</code></pre> <ul> <li><code>block</code>: Absolute index (0\u201363).</li> <li>Returns raw bytes \ud83d\udce6; <code>.hex()</code> for hex.</li> </ul>"},{"location":"usage/#33-write-16-bytes","title":"3.3 \u270d\ufe0f Write 16 Bytes","text":"<pre><code>payload = bytes(range(16))  # 0x00,0x01,...0x0F\nreader.write_block(block=4, data=payload)\n</code></pre> <ul> <li>Data length must be exactly 16 bytes \u26a0\ufe0f.</li> </ul>"},{"location":"usage/#4-sector-level-operations","title":"4\ufe0f\u20e3 Sector-Level Operations","text":""},{"location":"usage/#41-read-entire-sector","title":"4.1 \ud83d\udd04 Read Entire Sector","text":"<pre><code>sector_data = reader.read_sector(sector=2)\nfor offset, block in sector_data.items():\n    print(f\"Block {2*4 + offset}: {block.hex()}\")\n</code></pre> <ul> <li>Returns a dict <code>{offset: data}</code>.</li> </ul>"},{"location":"usage/#42-write-multiple-blocks","title":"4.2 \u270d\ufe0f Write Multiple Blocks","text":"<pre><code># Update blocks 0 and 2 of sector 2\nupdates = {\n    0: bytes([0xAA]*16),\n    2: bytes([0xBB]*16)\n}\nreader.write_sector(sector=2, data_blocks=updates)\n</code></pre> <ul> <li>Supplies a dict of offsets \u2192 bytes.</li> </ul>"},{"location":"usage/#5-bulk-block-operations","title":"5\ufe0f\u20e3 Bulk Block Operations","text":""},{"location":"usage/#51-reading-arbitrary-mapping","title":"5.1 \ud83d\udcda Reading Arbitrary Mapping","text":"<pre><code>mapping = {1: [0,1], 3: [2,3]}  # sector \u2192 list of offsets\ndata = reader.read_blocks(mapping=mapping, raw=True, combine=False)\n</code></pre> <ul> <li><code>mapping</code>: <code>{sector: [offsets]}</code>.</li> <li>Pass <code>keys</code>, <code>key_types</code>, <code>timeout</code>, <code>flush</code> as needed.</li> </ul>"},{"location":"usage/#52-writing-arbitrary-mapping","title":"5.2 \u270d\ufe0f Writing Arbitrary Mapping","text":"<pre><code>mapping = {\n    1: bytes(range(48)),\n    2: {1: bytes([0x11]*16), 3: bytes([0x22]*16)}\n}\nreader.write_blocks(mapping=mapping)\n</code></pre> <ul> <li>Supports 16-byte, 48-byte blobs, or per-offset dicts.</li> </ul>"},{"location":"usage/#6-error-handling","title":"6\ufe0f\u20e3 Error Handling","text":"<ul> <li><code>InvalidMessage</code>: Framing/CRC errors \u274c.</li> <li><code>GNetPlusError</code>: Reader-reported NAK errors \ud83d\udeab.</li> <li><code>ValueError</code>: Bad args or lengths \u26a0\ufe0f.</li> <li><code>TimeoutError</code>: No card in <code>wait_for_card</code> \u23f1\ufe0f.</li> </ul> <pre><code>try:\n    reader.read_block(5)\nexcept GNetPlusError as e:\n    print(\"Device error:\", e)\nexcept InvalidMessage as e:\n    print(\"Protocol error:\", e)\n</code></pre>"},{"location":"usage/#7-troubleshooting-tips","title":"7\ufe0f\u20e3 Troubleshooting Tips","text":"<ul> <li>Permissions: <code>sudo usermod -aG dialout $USER</code> (Linux) \ud83d\udd12.</li> <li>Port Busy: Close other apps using the COM port \ud83d\udeaa.</li> <li>Timeouts: Increase via <code>MifareReader(timeout=5)</code> or adjust code \u23f2\ufe0f.</li> <li>Key Mismatch: Ensure correct Key A/B \ud83d\udd11.</li> <li>Firmware: Check <code>get_version()</code> for compatibility \ud83d\udd0d.</li> </ul> <p>For more examples, see examples and for a full API reference, see api. \ud83c\udf89</p>"}]}